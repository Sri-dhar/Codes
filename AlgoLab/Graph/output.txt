Enter the number of nodes: 
The code uses zero-based indexing
Enter an edge only one time

Enter the number of neighbors for node 0: Enter neighbors and corresponding edge weights for node 0 separated by space: Enter the number of neighbors for node 1: Enter neighbors and corresponding edge weights for node 1 separated by space: Enter the number of neighbors for node 2: Enter neighbors and corresponding edge weights for node 2 separated by space: Enter the number of neighbors for node 3: Enter neighbors and corresponding edge weights for node 3 separated by space: Enter the number of neighbors for node 4: Enter neighbors and corresponding edge weights for node 4 separated by space: Enter the number of neighbors for node 5: Enter neighbors and corresponding edge weights for node 5 separated by space: Enter the number of neighbors for node 6: Enter neighbors and corresponding edge weights for node 6 separated by space: Your Adjacenct List is : 
Node 0 is connected to: 2 (weight: 1) 4 (weight: 2) 
Node 1 is connected to: 2 (weight: 7) 3 (weight: 1) 
Node 2 is connected to: 0 (weight: 1) 1 (weight: 7) 4 (weight: 6) 
Node 3 is connected to: 1 (weight: 1) 4 (weight: 5) 5 (weight: 2) 
Node 4 is connected to: 0 (weight: 2) 2 (weight: 6) 3 (weight: 5) 6 (weight: 4) 
Node 5 is connected to: 3 (weight: 2) 6 (weight: 3) 
Node 6 is connected to: 4 (weight: 4) 5 (weight: 3) 

Minimum Spanning Tree Edges Using Prims Algorithm:
0 - 2 with weight: 1
0 - 4 with weight: 2
4 - 6 with weight: 4
6 - 5 with weight: 3
5 - 3 with weight: 2
3 - 1 with weight: 1


Minimum Spanning Tree Edges Using Kruskal Algorithm:
0 - 2 with weight: 1
1 - 3 with weight: 1
5 - 3 with weight: 2
4 - 0 with weight: 2
6 - 5 with weight: 3
4 - 6 with weight: 4


Shortest Path Using BFS Output : 
Node 0 ==> 0
Node 1 ==> 8
Node 2 ==> 1
Node 3 ==> 7
Node 4 ==> 2
Node 5 ==> 9
Node 6 ==> 6
